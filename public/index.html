<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sentient Mosaic — robust</title>
  <style>
    :root{--bg:#000;--panel:#0f1115;--ring:#222531;--muted:#9aa3a9;--text:#e5e7eb;--accent:#6366f1;--logo:#0ea5e9}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;display:flex;flex-direction:column;align-items:center;gap:10px}
    .wrap{width:min(1200px,95vw)}
    .toolbar{background:var(--panel);border:1px solid var(--ring);border-radius:12px;padding:12px;display:grid;gap:10px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .toolbar input[type="text"],.toolbar input[type="url"]{background:#0b0d12;color:var(--text);border:1px solid var(--ring);border-radius:8px;padding:8px 10px;min-width:200px}
    .toolbar input[type="file"]{color:var(--muted)}
    .toolbar label{font-size:12px;color:var(--muted)}
    .toolbar .seg{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{background:#1b1f2b;color:var(--text);border:1px solid var(--ring);border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn.primary{background:#5046e4;color:#fff;border:none}
    .hint{color:var(--muted);font-size:12px;margin-top:-4px}
    .stage{background:#0b0b0b;border:1px dashed #2a2f3b;border-radius:12px;padding:10px;display:flex;justify-content:center;align-items:center;margin:6px 0}
    canvas{display:block;background:#000;border-radius:10px}
    .legend{color:var(--muted);font-size:12px;text-align:center}
    .status{font-size:12px;color:#fca5a5;text-align:center;min-height:18px}
    .pill{padding:2px 8px;border-radius:999px;background:#11162a;border:1px solid #1d2440;color:#9fb4ff;font-size:11px}
    .sp{flex:1}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="toolbar">
      <div class="row">
        <span class="pill">Kaynak</span>
        <label><input type="radio" name="src" value="url" checked> Mask URL</label>
        <label><input type="radio" name="src" value="text"> Metin</label>
        <label><input type="radio" name="src" value="upload"> Görsel yükle</label>
        <span class="sp"></span>
        <label><input id="darkIsLogo" type="checkbox" checked> Koyu piksel = logo</label>
        <label> Eşik <input id="thr" type="range" min="0" max="255" value="100"> <span id="thrVal">100</span></label>
      </div>
      <div class="row" id="rowUrl">
        <label>Mask URL</label>
        <input id="maskUrl" type="url" value="/mask.png" placeholder="/mask.png veya https://..."/>
      </div>
      <div class="row" id="rowText" style="display:none">
        <label>Metin</label>
        <input id="textInput" type="text" value="SENTIENT"/>
        <label>Yazı boyutu <input id="fontPx" type="range" min="24" max="240" value="160"> <span id="fontPxVal">160</span> px</label>
      </div>
      <div class="row" id="rowUpload" style="display:none">
        <input id="file" type="file" accept="image/png,image/jpeg,image/webp"/>
      </div>
      <div class="row">
        <label>Izgara: <span id="colsLab">40</span>x<span id="rowsLab">40</span> hücre, hücre <span id="cellLab">16</span> px</label>
        <input id="cols" type="range" min="16" max="96" value="40">
        <input id="rows" type="range" min="16" max="96" value="40">
        <input id="cell" type="range" min="8" max="30" value="16">
        <span class="sp"></span>
        <button id="btnRender" class="btn primary">Yeniden oluştur</button>
        <button id="btnDownload" class="btn">PNG indir</button>
        <button id="btnClearSel" class="btn">Seçimi temizle</button>
        <button id="btnPlace" class="btn">Seçilen hücreye yerleştir</button>
      </div>
      <div class="hint">Not: Harici bir CDN kullanıyorsan, CORS açık değilse mask görüntüsü yüklenmeyebilir. Bu durumda <b>Metin</b> ya da <b>Görsel yükle</b> seçeneğini kullan.</div>
    </div>

    <div class="stage">
      <canvas id="mosaic" aria-label="Sentient Mosaic"></canvas>
    </div>

    <div id="status" class="status"></div>
    <div class="legend">Logo hücreleri <span style="color:var(--logo)">daire</span> olarak çizilir, zemin siyahtır. Hücreye tıklayarak seçim yapabilirsin.</div>
  </div>

<script>
;(() => {
  // ------- State & helpers -------
  const $ = (s) => document.querySelector(s)
  const $$ = (s) => Array.from(document.querySelectorAll(s))

  const canvas = $('#mosaic')
  const ctx = canvas.getContext('2d', { willReadFrequently: true })
  const statusEl = $('#status')

  const ui = {
    srcRadios: () => $$('input[name="src"]'),
    maskUrl: $('#maskUrl'),
    textInput: $('#textInput'),
    fontPx: $('#fontPx'),
    fontPxVal: $('#fontPxVal'),
    file: $('#file'),
    thr: $('#thr'), thrVal: $('#thrVal'),
    darkIsLogo: $('#darkIsLogo'),
    cols: $('#cols'), rows: $('#rows'), cell: $('#cell'),
    colsLab: $('#colsLab'), rowsLab: $('#rowsLab'), cellLab: $('#cellLab'),
    rowUrl: $('#rowUrl'), rowText: $('#rowText'), rowUpload: $('#rowUpload'),
    btnRender: $('#btnRender'), btnDownload: $('#btnDownload'),
    btnPlace: $('#btnPlace'), btnClearSel: $('#btnClearSel')
  }

  const state = {
    gridCols: 40,
    gridRows: 40,
    cellPx: 16,
    grid: null, // boolean[][]
    placements: new Map(), // key "x,y" -> { tw, note }
    selected: null, // {x,y}
    srcKind: 'url',
  }

  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1))

  function setCanvasSize() {
    const wCss = state.gridCols * state.cellPx
    const hCss = state.gridRows * state.cellPx
    canvas.width = Math.floor(wCss * DPR)
    canvas.height = Math.floor(hCss * DPR)
    canvas.style.width = wCss + 'px'
    canvas.style.height = hCss + 'px'
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0)
  }

  function paintBG(){ ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height) }

  function drawGrid(){
    paintBG()
    const cell = state.cellPx
    const rows = state.gridRows, cols = state.gridCols
    const grid = state.grid

    // logo dots
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--logo').trim() || '#0ea5e9'
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        if(!grid || !grid[y][x]) continue
        const cx = x*cell + cell/2
        const cy = y*cell + cell/2
        const r = Math.floor(cell*0.45)
        ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill()
      }
    }

    // grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1
    for(let x=0;x<=cols;x++){ ctx.beginPath(); ctx.moveTo(x*cell,0); ctx.lineTo(x*cell,rows*cell); ctx.stroke() }
    for(let y=0;y<=rows;y++){ ctx.beginPath(); ctx.moveTo(0,y*cell); ctx.lineTo(cols*cell,y*cell); ctx.stroke() }

    // placements
    for(const [key, meta] of state.placements.entries()){
      const [x,y] = key.split(',').map(Number)
      const cx = x*cell + cell/2, cy = y*cell + cell/2
      ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx,cy,Math.max(2, cell*0.18),0,Math.PI*2); ctx.fill()
    }

    // selection highlight
    if(state.selected){
      const {x,y} = state.selected
      ctx.strokeStyle = '#93c5fd'; ctx.lineWidth = 2
      ctx.strokeRect(x*cell+1, y*cell+1, cell-2, cell-2)
    }
  }

  // ---------- Grid builders ----------
  function boolGrid(rows, cols, fill=false){
    return Array.from({length: rows}, () => Array(cols).fill(fill))
  }

  function sampleToGrid(sampleCanvas, rows, cols){
    // Resample to rows x cols and threshold
    const t = document.createElement('canvas')
    t.width = cols; t.height = rows
    const tctx = t.getContext('2d', { willReadFrequently: true })
    tctx.imageSmoothingEnabled = false
    tctx.drawImage(sampleCanvas, 0, 0, cols, rows)

    const data = tctx.getImageData(0,0,cols,rows).data
    const grid = boolGrid(rows, cols, false)
    const T = +ui.thr.value
    const darkIsLogo = ui.darkIsLogo.checked

    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const i = (y*cols + x)*4
        const r = data[i], g=data[i+1], b=data[i+2], a=data[i+3]
        const L = 0.2126*r + 0.7152*g + 0.0722*b
        let isLogo
        if(darkIsLogo){
          isLogo = (a>40) && (L <= T)
        } else {
          isLogo = (a>40) && (L >= (255 - T))
        }
        grid[y][x] = !!isLogo
      }
    }
    return grid
  }

  function buildGridFromText(text){
    const rows = state.gridRows, cols = state.gridCols
    const sc = document.createElement('canvas')
    sc.width = cols*4; sc.height = rows*4 // oversample for smoother edges
    const sctx = sc.getContext('2d')
    sctx.clearRect(0,0,sc.width, sc.height)
    sctx.fillStyle = '#000'; sctx.fillRect(0,0,sc.width, sc.height)
    sctx.fillStyle = '#fff'
    sctx.textBaseline = 'middle'; sctx.textAlign = 'center'
    const fs = +ui.fontPx.value
    sctx.font = `800 ${fs}px system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial`
    sctx.fillText(text || 'SENTIENT', sc.width/2, sc.height/2)
    return sampleToGrid(sc, rows, cols)
  }

  function buildGridFromImage(img){
    const rows = state.gridRows, cols = state.gridCols
    const sc = document.createElement('canvas')
    sc.width = img.naturalWidth; sc.height = img.naturalHeight
    const sctx = sc.getContext('2d')
    sctx.drawImage(img,0,0)
    return sampleToGrid(sc, rows, cols)
  }

  function buildGridFromUrl(url){
    return new Promise((resolve) => {
      const img = new Image()
      try {
        const link = document.createElement('a'); link.href = url
        const sameOrigin = (link.origin === window.location.origin)
        if(!sameOrigin) img.crossOrigin = 'anonymous'
      } catch {}
      img.onload = () => resolve(buildGridFromImage(img))
      img.onerror = () => resolve(null)
      img.src = url
    })
  }

  // ---------- Render pipeline ----------
  async function render(){
    state.gridCols = +ui.cols.value
    state.gridRows = +ui.rows.value
    state.cellPx = +ui.cell.value

    ui.colsLab.textContent = state.gridCols
    ui.rowsLab.textContent = state.gridRows
    ui.cellLab.textContent = state.cellPx

    setCanvasSize()

    let grid = null
    const srcKind = state.srcKind
    statusEl.textContent = ''

    if(srcKind === 'url'){
      grid = await buildGridFromUrl(ui.maskUrl.value.trim())
      if(!grid){
        statusEl.textContent = 'Mask yüklenemedi, metin fallback kullanıldı.'
        grid = buildGridFromText(ui.textInput.value)
      }
    } else if(srcKind === 'text'){
      grid = buildGridFromText(ui.textInput.value)
    } else if(srcKind === 'upload'){
      const f = ui.file.files && ui.file.files[0]
      if(!f){ statusEl.textContent = 'Bir görsel seçmelisin.'; grid = buildGridFromText(ui.textInput.value) }
      else {
        const url = URL.createObjectURL(f)
        const img = new Image()
        await new Promise((res)=>{ img.onload = () => res(); img.onerror = () => res(); img.src = url })
        URL.revokeObjectURL(url)
        grid = img.complete && img.naturalWidth ? buildGridFromImage(img) : buildGridFromText(ui.textInput.value)
      }
    }

    state.grid = grid || boolGrid(state.gridRows, state.gridCols, false)
    drawGrid()
  }

  // ---------- Selection & placement ----------
  function pixelToCell(ev){
    const rect = canvas.getBoundingClientRect()
    const x = ev.clientX - rect.left
    const y = ev.clientY - rect.top
    const sx = Math.floor(x / (rect.width / state.gridCols))
    const sy = Math.floor(y / (rect.height / state.gridRows))
    return {x: Math.max(0, Math.min(state.gridCols-1, sx)), y: Math.max(0, Math.min(state.gridRows-1, sy))}
  }

  canvas.addEventListener('click', (ev) => {
    const {x,y} = pixelToCell(ev)
    state.selected = {x,y}
    drawGrid()
  })

  ui.btnClearSel.addEventListener('click', () => { state.selected = null; drawGrid() })

  ui.btnPlace.addEventListener('click', () => {
    if(!state.selected){ statusEl.textContent = 'Önce bir hücre seç.'; return }
    const key = state.selected.x+','+state.selected.y
    if(state.placements.has(key)) state.placements.delete(key)
    else state.placements.set(key, {tw: '', note: ''})
    drawGrid()
  })

  // ---------- Exports ----------
  ui.btnDownload.addEventListener('click', () => {
    const exportScale = 2
    const out = document.createElement('canvas')
    out.width = canvas.width * exportScale / DPR
    out.height = canvas.height * exportScale / DPR
    const o = out.getContext('2d')
    o.scale(exportScale, exportScale)
    // draw using current routine at 1x logical scale
    const prev = { c: canvas, x: ctx }
    const tmp = { drawGrid }
    // Quick redraw into offscreen by temporarily redirecting context is overkill; instead re-run drawing logic with an isolated context
    // We duplicate essential bits:
    o.fillStyle = '#000'; o.fillRect(0,0,out.width,out.height)
    const cell = state.cellPx
    // logo
    o.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--logo').trim() || '#0ea5e9'
    for(let y=0;y<state.gridRows;y++){
      for(let x=0;x<state.gridCols;x++){
        if(!state.grid || !state.grid[y][x]) continue
        const cx = x*cell + cell/2
        const cy = y*cell + cell/2
        const r = Math.floor(cell*0.45)
        o.beginPath(); o.arc(cx,cy,r,0,Math.PI*2); o.fill()
      }
    }
    // grid lines
    o.strokeStyle = 'rgba(255,255,255,0.06)'; o.lineWidth = 1
    for(let x=0;x<=state.gridCols;x++){ o.beginPath(); o.moveTo(x*cell,0); o.lineTo(x*cell,state.gridRows*cell); o.stroke() }
    for(let y=0;y<=state.gridRows;y++){ o.beginPath(); o.moveTo(0,y*cell); o.lineTo(state.gridCols*cell,y*cell); o.stroke() }
    // placements
    for(const [key, meta] of state.placements.entries()){
      const [x,y] = key.split(',').map(Number)
      const cx = x*cell + cell/2, cy = y*cell + cell/2
      o.fillStyle = '#fff'; o.beginPath(); o.arc(cx,cy,Math.max(2, cell*0.18),0,Math.PI*2); o.fill()
    }
    // selection (optional)
    if(state.selected){ const {x,y}=state.selected; o.strokeStyle='#93c5fd'; o.lineWidth=2; o.strokeRect(x*cell+1,y*cell+1,cell-2,cell-2) }

    const a = document.createElement('a')
    a.download = 'sentient-mosaic.png'
    a.href = out.toDataURL('image/png')
    a.click()
  })

  // ---------- UI wiring ----------
  function setSrc(kind){
    state.srcKind = kind
    ui.rowUrl.style.display = kind==='url' ? '' : 'none'
    ui.rowText.style.display = kind==='text' ? '' : 'none'
    ui.rowUpload.style.display = kind==='upload' ? '' : 'none'
  }

  ui.srcRadios().forEach(r => r.addEventListener('change', (e) => setSrc(e.target.value)))

  ui.fontPx.addEventListener('input', () => { ui.fontPxVal.textContent = ui.fontPx.value; render() })
  ui.thr.addEventListener('input', () => { ui.thrVal.textContent = ui.thr.value; render() })
  ui.darkIsLogo.addEventListener('change', render)
  ui.cols.addEventListener('input', () => { ui.colsLab.textContent = ui.cols.value; render() })
  ui.rows.addEventListener('input', () => { ui.rowsLab.textContent = ui.rows.value; render() })
  ui.cell.addEventListener('input', () => { ui.cellLab.textContent = ui.cell.value; render() })
  ui.maskUrl.addEventListener('change', render)
  ui.textInput.addEventListener('input', render)
  ui.file.addEventListener('change', render)

  ui.btnRender.addEventListener('click', render)
  window.addEventListener('resize', () => { setCanvasSize(); drawGrid() })

  // init
  setSrc('url')
  setCanvasSize()
  render()
})()
</script>
</body>
</html>
